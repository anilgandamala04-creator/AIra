import { TeachingStep } from '../../types';

export const sortingSteps: TeachingStep[] = [
    {
        id: 's-1',
        stepNumber: 1,
        title: 'Introduction to Sorting',
        content: 'Sorting algorithms arrange data in a specific order (ascending or descending). Common sorting algorithms include bubble sort, merge sort, quicksort, and heap sort, each with different time complexities.',
        spokenContent: 'Welcome to Sorting Algorithms! Sorting is one of the most fundamental operations in computer science. Think of it as organizing a disorganized library. We will explore different algorithms, each with its own unique approach to bringing order to chaos, along with the performance trade-offs that come with each method.',
        visualType: 'animation',
        visualPrompt: 'A disorganized array of vertical bars of varying heights being swept into a perfectly ordered ascending sequence with glowing highlights',
        durationSeconds: 160,
        completed: false,
        complexity: 'basic',
        estimatedMinutes: 3,
        keyConcepts: ['Data Ordering', 'Ascending/Descending', 'Time Complexity', 'Stability'],
        realWorldExamples: [
            'Sorting contacts by name in a phone',
            'Displaying products from lowest to highest price',
            'Search engines ranking results by relevance'
        ],
    },
    {
        id: 's-2',
        stepNumber: 2,
        title: 'Bubble Sort',
        content: 'Bubble sort repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. Time complexity: O(n²). Simple but inefficient for large datasets.',
        spokenContent: 'Bubble sort is often the first algorithm we learn. It works by repeatedly comparing adjacent elements and swapping them if they are in the wrong order. You can literally see the largest values "bubble up" to their correct positions at the end of the list. While it is simple to write, it becomes very slow as the amount of data grows.',
        visualType: 'animation',
        visualPrompt: 'Pairwise comparison animation where two adjacent glowing nodes swap positions repeatedly until the largest "bubbles" to the end',
        durationSeconds: 180,
        completed: false,
        complexity: 'basic',
        estimatedMinutes: 3,
        keyConcepts: ['Pairwise comparison', 'Adjacent swaps', 'In-place sorting', 'O(n²) Complexity'],
    },
    {
        id: 's-3',
        stepNumber: 3,
        title: 'Merge Sort',
        content: 'Merge sort uses divide-and-conquer: split the array in half, sort each half recursively, then merge the sorted halves. Time complexity: O(n log n). Stable and predictable performance.',
        spokenContent: 'Merge sort follows the "divide and conquer" philosophy. We break a big list down into tiny one-item lists, then merge them back together in perfect order. This systematic approach is much faster for large datasets, giving us a very predictable O of n log n performance, regardless of how disorganized the initial data was.',
        visualType: 'animation',
        visualPrompt: 'A hierarchical tree visualization showing a list splitting into sub-lists and then merging back up into a single sorted array with zip-like animations',
        durationSeconds: 200,
        completed: false,
        complexity: 'intermediate',
        estimatedMinutes: 4,
        keyConcepts: ['Divide and Conquer', 'Recursion', 'Stable Sort', 'O(n log n) Complexity'],
    },
    {
        id: 's-4',
        stepNumber: 4,
        title: 'Quicksort',
        content: 'Quicksort picks a pivot element, partitions the array around it, then recursively sorts the partitions. Average time: O(n log n), worst case: O(n²). Often fastest in practice.',
        spokenContent: 'Quicksort is arguably the most used sorting algorithm in the real world. It picks a "pivot" element and organizes everything else as being either smaller or larger than that pivot. By then repeating this process on each side, it achieves incredible speeds in practice. It is a brilliant example of how a clever strategy can outperform a simpler one.',
        visualType: 'animation',
        visualPrompt: 'Geometric partitioning view where a central "pivot" node sorts surrounding elements into two distinct clouds (lesser than and greater than)',
        durationSeconds: 200,
        completed: false,
        complexity: 'intermediate',
        estimatedMinutes: 4,
        keyConcepts: ['Pivot selection', 'Partitioning', 'In-place sorting', 'Average-case efficiency'],
    },
    {
        id: 's-5',
        stepNumber: 5,
        title: 'Algorithm Mastery Check',
        content: 'Compare sorting algorithms by time complexity, space complexity, stability, and best use cases. Choose based on data size and performance requirements.',
        spokenContent: 'You have mastered the big three! Before we move on, let us compare their stats. Knowing which tool to use for the job is what separates a great developer from a good one. Let’s do a quick check on big-O notation and stability.',
        visualType: 'technical',
        visualPrompt: 'Competitive comparison dashboard featuring a performance heatmap and complexity charts for Bubble, Merge, and QuickSort',
        durationSeconds: 150,
        completed: false,
        complexity: 'intermediate',
        estimatedMinutes: 3,
    },
];
