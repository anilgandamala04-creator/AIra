import { TeachingStep } from '../../types';

export const sortingSteps: TeachingStep[] = [
    {
        id: 's-1',
        stepNumber: 1,
        title: 'Introduction to Sorting',
        content: 'Sorting algorithms arrange data in a specific order (ascending or descending). Common sorting algorithms include bubble sort, merge sort, quicksort, and heap sort, each with different time complexities.',
        spokenContent: 'Welcome to Sorting Algorithms! Sorting is one of the most fundamental operations in computer science. We will explore different algorithms, each with unique strengths and trade-offs in speed and memory usage.',
        visualType: 'animation',
        durationSeconds: 120,
        completed: false,
    },
    {
        id: 's-2',
        stepNumber: 2,
        title: 'Bubble Sort',
        content: 'Bubble sort repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. Time complexity: O(n²). Simple but inefficient for large datasets.',
        spokenContent: 'Bubble sort is the simplest sorting algorithm. It compares pairs of adjacent elements and swaps them if needed, bubbling larger values to the end. While easy to understand, it is slow for large lists.',
        visualType: 'animation',
        durationSeconds: 140,
        completed: false,
    },
    {
        id: 's-3',
        stepNumber: 3,
        title: 'Merge Sort',
        content: 'Merge sort uses divide-and-conquer: split the array in half, sort each half recursively, then merge the sorted halves. Time complexity: O(n log n). Stable and predictable performance.',
        spokenContent: 'Merge sort divides the problem in half, sorts each half, then merges them together. This divide-and-conquer approach gives us O of n log n performance, making it efficient for large datasets.',
        visualType: 'animation',
        durationSeconds: 150,
        completed: false,
    },
    {
        id: 's-4',
        stepNumber: 4,
        title: 'Quicksort',
        content: 'Quicksort picks a pivot element, partitions the array around it, then recursively sorts the partitions. Average time: O(n log n), worst case: O(n²). Often fastest in practice.',
        spokenContent: 'Quicksort is often the fastest in practice. It picks a pivot, partitions elements around it, then recursively sorts each partition. While worst-case is slow, average performance is excellent.',
        visualType: 'animation',
        durationSeconds: 150,
        completed: false,
    },
    {
        id: 's-5',
        stepNumber: 5,
        title: 'Algorithm Comparison',
        content: 'Compare sorting algorithms by time complexity, space complexity, stability, and best use cases. Choose based on data size, data characteristics, and performance requirements.',
        spokenContent: 'Each algorithm has trade-offs. Bubble sort is simple but slow. Merge sort is stable and predictable. Quicksort is fast but can degrade. Choose based on your specific needs.',
        visualType: 'diagram',
        durationSeconds: 130,
        completed: false,
    },
];
