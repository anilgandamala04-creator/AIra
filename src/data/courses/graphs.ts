import { TeachingStep } from '../../types';

export const graphsSteps: TeachingStep[] = [
    {
        id: 'g-1',
        stepNumber: 1,
        title: 'Introduction to Graph Theory',
        content: 'Graph theory studies relationships between objects. A graph consists of vertices (nodes) connected by edges. Graphs model many real-world problems like social networks, maps, and computer networks.',
        spokenContent: 'Welcome to Graph Theory! At its simplest, a graph is a collection of points and the lines that connect them. But this simple idea allows us to model the entire world — from the billions of friendships on social media to the complex routing of the internet and the best paths for GPS navigation.',
        visualType: 'diagram',
        visualPrompt: 'Dynamic 3D social network web showing hundreds of interconnected nodes with glowing activity pulses',
        durationSeconds: 160,
        completed: false,
        complexity: 'basic',
        estimatedMinutes: 3,
        keyConcepts: ['Vertices (Nodes)', 'Edges (Connections)', 'Network Modeling', 'Relationships'],
        realWorldExamples: [
            'Facebook/LinkedIn social networks',
            'Google Maps road networks',
            'Internet packet routing'
        ],
    },
    {
        id: 'g-2',
        stepNumber: 2,
        title: 'Graph Components',
        content: 'Graphs have vertices (nodes) and edges (connections). Edges can be directed (one-way) or undirected (two-way). Graphs can be weighted (edges have values) or unweighted.',
        spokenContent: 'Graphs come in different flavors. Edges can be undirected, like a two-way street, or directed, like a one-way follow on Instagram. We also use "weights"—numbers assigned to edges to represent things like distance, cost, or time. These specialized components allow us to describe the world with incredible precision.',
        visualType: 'technical',
        visualPrompt: 'High-fidelity diagram showing directed (arrows), undirected (lines), and weighted (with numerical labels) edges connecting a cluster of nodes',
        durationSeconds: 180,
        completed: false,
        complexity: 'basic',
        estimatedMinutes: 3,
        keyConcepts: ['Directed/Undirected', 'Weighted Edges', 'Adjacency', 'Graph Topology'],
    },
    {
        id: 'g-3',
        stepNumber: 3,
        title: 'DFS vs BFS Traversal',
        content: 'Graph traversal algorithms visit all vertices. Depth-First Search (DFS) explores as far as possible before backtracking. Breadth-First Search (BFS) explores level by level, visiting neighbors first.',
        spokenContent: 'How do you explore a graph? Depth-First Search is like exploring a dark cave; you follow one tunnel to the very end before coming back to try the next. Breadth-First Search is more like a stone dropped in a pond; it visits all your immediate neighbors first, then their neighbors, and so on. Each has unique uses in computer science.',
        visualType: 'animation',
        visualPrompt: 'Dual-pane animation showing a DFS "deep dive" path versus a BFS "radial expansion" pattern through a complex grid of nodes',
        durationSeconds: 200,
        completed: false,
        complexity: 'intermediate',
        estimatedMinutes: 3,
        keyConcepts: ['DFS (Backtracking)', 'BFS (Level-order)', 'Queue/Stack usage', 'Connected Components'],
    },
    {
        id: 'g-4',
        stepNumber: 4,
        title: 'Dijkstra\'s Shortest Path',
        content: 'Dijkstra\'s algorithm finds the shortest path between nodes in a weighted graph. It uses a priority queue to always explore the closest unvisited node first, guaranteeing optimal paths.',
        spokenContent: 'When you ask for the fastest route home, you are using Dijkstra’s algorithm. It is a greedy algorithm that always picks the "closest" next step it can find. By systematically expanding the shortest known distance to every node, it eventually finds the absolute best path across the entire network.',
        visualType: 'animation',
        visualPrompt: 'Pathfinding simulation showing a light pulse finding the optimal path through a weighted mesh network with real-time distance calculations',
        durationSeconds: 200,
        completed: false,
        complexity: 'advanced',
        estimatedMinutes: 4,
        keyConcepts: ['Greedy Algorithm', 'Priority Queue', 'Optimal Path', 'Cost Minimization'],
    },
    {
        id: 'g-5',
        stepNumber: 5,
        title: 'Graph Mastery Check',
        content: 'Apply graph algorithms to solve pathfinding and relationship problems in various datasets.',
        spokenContent: 'Great work! You now understand the skeletal structure of information. Let’s do a master check to see if you can choose the right traversal method and recognize the components of a complex network.',
        visualType: 'interactive',
        visualPrompt: 'Interactive network editor where users can place nodes and run BFS/DFS simulations with step-by-step visualizations',
        durationSeconds: 220,
        completed: false,
        complexity: 'advanced',
        estimatedMinutes: 4,
    },
];
