import { TeachingStep } from '../../types';

export const stateManagementSteps: TeachingStep[] = [
    {
        id: 'sm-1',
        stepNumber: 1,
        title: 'Why State Management?',
        content: 'As applications grow, managing state becomes complex. State management solutions help organize, share, and update application data across multiple components efficiently.',
        spokenContent: 'Welcome to State Management! As your React app grows, passing props through many components becomes messy. State management libraries help you organize and share data across your entire application.',
        visualType: 'diagram',
        durationSeconds: 120,
        completed: false,
    },
    {
        id: 'sm-2',
        stepNumber: 2,
        title: 'Local vs Global State',
        content: 'Local state (useState) is component-specific. Global state is shared across components. Choose local state for component-specific data, global state for data needed by multiple components.',
        spokenContent: 'State can be local or global. Local state lives in a single component - perfect for things like form inputs. Global state is accessible everywhere - ideal for user data, theme settings, or shopping cart contents.',
        visualType: 'diagram',
        durationSeconds: 140,
        completed: false,
    },
    {
        id: 'sm-3',
        stepNumber: 3,
        title: 'Context API',
        content: 'React\'s Context API provides a way to share values between components without prop drilling. Create a context, provide it at a high level, and consume it where needed.',
        spokenContent: 'The Context API is React\'s built-in solution for sharing state. You create a context, wrap your app with a provider, and any component can access that data. It eliminates the need to pass props through every level.',
        visualType: 'diagram',
        durationSeconds: 150,
        completed: false,
    },
    {
        id: 'sm-4',
        stepNumber: 4,
        title: 'External Libraries',
        content: 'Popular state management libraries include Redux (predictable state container), Zustand (lightweight), and Recoil (atomic state). Each has different trade-offs in complexity and features.',
        spokenContent: 'For complex apps, external libraries offer powerful tools. Redux provides a predictable state container with time-travel debugging. Zustand is minimal and easy to use. Recoil offers fine-grained reactivity. Choose based on your needs.',
        visualType: 'text',
        durationSeconds: 160,
        completed: false,
    },
    {
        id: 'sm-5',
        stepNumber: 5,
        title: 'Best Practices',
        content: 'Keep state as close to where it\'s used as possible. Normalize complex state. Use selectors to derive computed values. Avoid unnecessary re-renders with proper memoization.',
        spokenContent: 'Follow best practices: keep state local when possible, normalize nested data structures, use selectors for derived values, and optimize with memoization. Good state management makes apps faster and easier to maintain.',
        visualType: 'text',
        durationSeconds: 140,
        completed: false,
    },
];
