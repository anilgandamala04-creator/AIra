import { TeachingStep } from '../../types';

export const stateManagementSteps: TeachingStep[] = [
    {
        id: 'sm-1',
        stepNumber: 1,
        title: 'Why State Management?',
        content: 'As applications grow, managing state becomes complex. State management solutions help organize, share, and update application data across multiple components efficiently.',
        spokenContent: 'Welcome to State Management! As your React app grows, passing props through many components becomes messy - a problem we call prop drilling. State management libraries help you organize and share data across your entire application using a central source of truth.',
        visualType: 'diagram',
        visualPrompt: 'Comparison visualization of prop drilling mess versus an organized central state repository with direct access lines',
        durationSeconds: 180,
        completed: false,
        complexity: 'basic',
        estimatedMinutes: 3,
        keyConcepts: ['Prop Drilling', 'Centralized State', 'Source of Truth', 'Scalability'],
        realWorldExamples: [
            'User authentication state used by every page',
            'Shopping cart data shared between product list and checkout',
            'Theme settings (dark/light mode) applied globally'
        ],
    },
    {
        id: 'sm-2',
        stepNumber: 2,
        title: 'Local vs Global State',
        content: 'Local state (useState) is component-specific. Global state is shared across components. Choose local state for component-specific data, global state for data needed by multiple components.',
        spokenContent: 'State can be local or global. Local state lives in a single component - perfect for things like form inputs or toggles. Global state is accessible everywhere - ideal for data that doesn\'t belong to just one piece of the UI, like a user\'s profile or notification settings.',
        visualType: 'diagram',
        visualPrompt: 'Dual-panel view showing local state isolated within a component versus global state shared across a whole component tree',
        durationSeconds: 180,
        completed: false,
        complexity: 'intermediate',
        estimatedMinutes: 3,
        keyConcepts: ['Local State', 'Global State', 'Component Scope', 'Data Sharing'],
    },
    {
        id: 'sm-3',
        stepNumber: 3,
        title: 'Context API',
        content: 'React\'s Context API provides a way to share values between components without prop drilling. Create a context, provide it at a high level, and consume it where needed.',
        spokenContent: 'The Context API is React\'s built-in solution for sharing state without libraries. You create a context, wrap your app with a provider, and then any component nested inside can "consume" that data directly. It\'s powerful for mid-sized apps and theme/auth data.',
        visualType: 'diagram',
        visualPrompt: 'Hierarchical tree diagram showing a Context Provider at the top broadcasting state to deep nested consumer components',
        durationSeconds: 180,
        completed: false,
        complexity: 'intermediate',
        estimatedMinutes: 3,
        keyConcepts: ['Context Provider', 'Context Consumer', 'useContext hook', 'Dependency injection'],
    },
    {
        id: 'sm-4',
        stepNumber: 4,
        title: 'External Libraries',
        content: 'Popular state management libraries include Redux (predictable state container), Zustand (lightweight), and Recoil (atomic state). Each has different trade-offs in complexity and features.',
        spokenContent: 'For complex apps, external libraries offer specialized tools. Redux is the classic choice with strict patterns and great debugging. Zustand is the modern favorite - it\'s incredibly lightweight and easy to learn. Recoil takes an "atomic" approach, letting you update individual pieces of state independently. Your choice depends on the project size and team preference.',
        visualType: 'animation',
        visualPrompt: 'Animated carousel showing Redux (Actions/Reducers loop), Zustand (Simple hook access), and Recoil (Atomic independent bubbles)',
        durationSeconds: 200,
        completed: false,
        complexity: 'advanced',
        estimatedMinutes: 4,
        keyConcepts: ['Redux', 'Zustand', 'Recoil', 'Atomic State', 'Immutability'],
    },
    {
        id: 'sm-5',
        stepNumber: 5,
        title: 'Best Practices',
        content: 'Keep state as close to where it\'s used as possible. Normalize complex state. Use selectors to derive computed values. Avoid unnecessary re-renders with proper memoization.',
        spokenContent: 'Great state management follows four key rules: Keep state as local as possible. Normalize nested data to make updates easier. Use selectors to calculate "derived" data like a cart total. And finally, use memoization to ensure your app stays lightning fast even with massive amounts of data.',
        visualType: 'technical',
        visualPrompt: 'Optimization dashboard showing memoization benefits, normalized data tables, and minimal re-render indicators',
        durationSeconds: 200,
        completed: false,
        complexity: 'advanced',
        estimatedMinutes: 3,
        keyConcepts: ['Normalization', 'Memoization', 'Derived State', 'Performance Tuning'],
        practicalApplications: [
            'Avoid "ghost re-renders" in large lists',
            'Handle deeply nested API responses efficiently',
            'Implement undo/redo functionality'
        ],
    },
];
